---
layout: post
date: 2025-04-03
title: Асинхронность в Ruby
---

Зачем вообще разработчику думать об асинхронности?
## Скорость!

Нам нужно обработать 1000 документов? Нам нужно сделать 1000 запросов? Нам нужно выполнить 1000 фоновых задач? Делать это по очереди может быть долго. Очень долго!

Рассмотрим простой пример: если мы делаем 100 HTTP-запросов последовательно, это займет значительно больше времени, чем если мы сделаем их параллельно.

```ruby
require 'net/http'
require 'uri'

def response(url) = Net::HTTP.get_response(URI.parse(url))

urls = (1..100).map { |i| "https://example.com/#{i}" }
results = []

urls.each { |url| results << response(url) } # 100 sec
```

Проблема в том, что мы начинаем выполнять следующий запрос только после окончания предыдущего. Однако, это вовсе не обязательно:

```ruby
urls.each { |url| Thread.new { results << response(url) } } # 1 sec
```

Почему это возможно? Дело в том, что в реальных задачах процессор почти все время простаивает, потому что мы ждем ответа от устройств ввода/вывода, таких как сеть, диск, база данных (тоже сеть). А еще у нас у каждого уже давно не сервера, а "*суперкомпьютеры*", на которых куча ядер. Так что тут есть большой простор для ускорения наших приложений.

Но разве мы для этого покупали дорогой CPU, чтобы он отдыхал? Отдыхать должен рубист, а компьютер должен работать. Пока процессор ждет ответ, почему бы его не занять чем-то полезным, например, обработкой следующей задачи. А как придет ответ от сети, можно переключиться обратно.

*Забегая вперед, скажу, что в Ruby on Rails асинхронность уже присутствует: Puma использует потоки и процессы для параллельной обработки запросов, а Sidekiq выполняет задачи параллельно.*

Для эффективной работы необходимо, чтобы одна задача не блокировала другие, и для этого нужна асинхронность.

## Параллельность vs конкурентность

Часто возникают вопросы о параллельности и конкурентности. В чем же разница?

**Параллельность** подразумевает одновременное выполнение нескольких задач на разных ядрах процессора. Это "реальное" выполнение одновременно.

**Конкурентность** же – это способность системы обрабатывать несколько задач, создавая иллюзию одновременного выполнения. Это может достигаться путем быстрого переключения между задачами на одном ядре.

Ключевое отличие: параллельность требует нескольких ядер, а конкурентность – нет. Конкурентность позволяет добиться прогресса, даже если у вас только одно ядро.

Тут можно вспомнить про GIL, который ограничивает параллельное выполнение в MRI. Из-за этого механизма программа на ruby не может задействовать больше 1 ядра CPU. Это серьезное ограничение, но его можно преодолеть. Увидим чуть позже.

Для простоты я буду использовать термин **асинхронность**,  к этому понятию относится как конкурентность, так и параллелизм. 

Какие механизмы ассинхронности у нас есть в Ruby?
## Process

Процесс — это механизм операционной системы, который позволяет запустить несколько независимых программ.

В Ruby процессы представляют собой запуск отдельных экземпляров интерпретатора, где каждый экземпляр работает в своём изолированном адресном пространстве. Это позволяет обойти ограничение GIL (Global Interpreter Lock), характерное для MRI, и использовать все доступные ядра. 

Пример простого использования `fork`:

```ruby
pid = fork do
  puts "Это выполняется в дочернем процессе"
end

Process.wait(pid)
puts "Дочерний процесс завершён"
```

Однако, такие процессы не могут иметь общих переменных. И координировать процессы становится сложно: нужно использовать сокеты, порты, внешние ресурсы (бд, редис, очереди). 

**Преимущества**: 
- используются все ядра

**Недостатки**:
- самый ресурсоемкий вариант
- нет простого способа коммуницировать между процессами

## Thread

Потоки в Ruby позволяют выполнять несколько нитей внутри одного процесса, что особенно полезно для I/O-ориентированных задач. Нить (thread) — это единица исполнения внутри процесса операционной системы. Она позволяет выполнять несколько задач одновременно, используя ресурсы одного процесса. Хотя использование потоков позволяет добиться конкурентного выполнения, в MRI ограничение GIL (Global Interpreter Lock) не позволяет выполнять CPU-ориентированные задачи параллельно в полном объёме. Тем не менее, для задач, где программа часто ожидает внешние события, потоки становятся удобным инструментом.

Минимальный пример использования потоков:

```ruby
thread = Thread.new do
  puts "Работа потока"
  sleep 1
  puts "Поток завершён"
end

thread.join
puts "Основной поток продолжил выполнение"
```

При использовании потоков важно уделять внимание синхронизации доступа к разделяемым данным, чтобы избежать гонок и дедлоков.

**Преимущества**:
- эффективнее, чем процессы
- могут иметь общие переменные в рамках одного процесса
**Недостатки**:
- используется 1 ядро
- ограничение GIL - параллельно исполняется только 1 поток
- все же, высокое потребление ресурсов, если сравнивать с легковесными потоками (см Fiber)

## Fiber

В современных языках программирования наряду с потоками существуют встроенные легковесные примитивы для организации асинхронного кода: горутины в Go, корутины в Kotlin, файберы в Ruby.

Файберы – это легковесные примитивы для реализации кооперативной многозадачности, позволяющие явно передавать управление между различными блоками кода. Они работают в рамках одного потока, что упрощает управление состоянием, однако ответственность за передачу управления полностью ложится на программиста. Файберы отлично подходят для реализации асинхронного ввода-вывода и нелинейного исполнения кода.

Пример использования файбера:

```ruby
fiber = Fiber.new do
  puts "Начало работы файбера"
  Fiber.yield
  puts "Возобновление работы файбера"
end

fiber.resume
puts "Между резюме"
fiber.resume
```

**Преимущества:**
* простота использования
* эффективность по ресурсам

**Недостатки:**
* используется только одно ядро

### Ractor

Ractor = **R**uby **Actor**




```ruby
results = urls.map do |url|
  Ractor.new(url) do |url|
    response(url)
  end
end

puts results.map(&:take)
```



Ractor — это параллельная модель выполнения в Ruby, вдохновленная Erlang. Она позволяет создавать независимые процессы (ractors), которые обмениваются сообщениями, избегая общих изменяемых данных и, следовательно, проблем с блокировками. Ractor подходит для задач, требующих высокой степени параллелизма и отказоустойчивости.

```ruby
# Пример взаимодействия двух Ractor'ов

require 'ractors'

Ractor.new do
  mailbox.post :hello
end

Ractor.new do
  receive do |message|
    puts "Получено: #{message}"
    mailbox.post :world
  end
  receive do |message|
    puts "Получено: #{message}"
  end
end
```

В этом примере первый Ractor отправляет сообщение `:hello` во второй Ractor. Второй Ractor получает это сообщение, выводит его на консоль и затем отправляет сообщение `:world` обратно в первый Ractor. Первый Ractor, в свою очередь, ожидает получения сообщения `:world`.