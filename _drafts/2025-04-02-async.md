---
layout: post
date: 2025-04-03
title: Асинхронность в Ruby
---

Зачем вообще разработчику думать об асинхронности?
## Скорость!

Нам нужно обработать 1000 документов? Нам нужно сделать 1000 запросов? Нам нужно выполнить 1000 фоновых задач? Делать это по очереди может быть долго. Очень долго!

Рассмотрим простой пример: если мы делаем 100 HTTP-запросов последовательно, это займет значительно больше времени, чем если мы сделаем их параллельно.

```ruby
require 'net/http'
require 'uri'

def response(url) = Net::HTTP.get_response(URI.parse(url))

urls = (1..100).map { |i| "https://example.com/#{i}" }
results = []

urls.each { |url| results << response(url) } # 100 sec
```

Проблема в том, что мы начинаем выполнять следующий запрос только после окончания предыдущего. Однако, это вовсе не обязательно:

```ruby
urls.each { |url| Thread.new { results << response(url) } } # 1 sec
```

Почему это возможно? Дело в том, что в реальных задачах процессор почти все время простаивает, потому что мы ждем ответа от устройств ввода/вывода, таких как сеть, диск, база данных (тоже сеть). А еще у нас у каждого уже давно не сервера, а "*суперкомпьютеры*", на которых куча ядер. Так что тут есть большой простор для ускорения наших приложений.

Но разве мы для этого покупали дорогой CPU, чтобы он отдыхал? Отдыхать должен рубист, а компьютер должен работать. Пока процессор ждет ответ, почему бы его не занять чем-то полезным, например, обработкой следующей задачи. А как придет ответ от сети, можно переключиться обратно.

*Забегая вперед, скажу, что в Ruby on Rails асинхронность уже присутствует: Puma использует потоки и процессы для параллельной обработки запросов, а Sidekiq выполняет задачи параллельно.*

Для эффективной работы необходимо, чтобы одна задача не блокировала другие, и для этого нужна асинхронность.

## Параллельность vs конкурентность

Часто возникают вопросы о параллельности и конкурентности. В чем же разница?

**Параллельность** подразумевает одновременное выполнение нескольких задач на разных ядрах процессора. Это "реальное" выполнение одновременно.

**Конкурентность** же – это способность системы обрабатывать несколько задач, создавая иллюзию одновременного выполнения. Это может достигаться путем быстрого переключения между задачами на одном ядре.

Ключевое отличие: параллельность требует нескольких ядер, а конкурентность – нет. Конкурентность позволяет добиться прогресса, даже если у вас только одно ядро.

Тут можно вспомнить про GIL, который ограничивает параллельное выполнение в MRI. Из-за этого механизма программа на ruby не может задействовать больше 1 ядра CPU. Это серьезное ограничение, но его можно преодолеть. Увидим чуть позже.

Для простоты я буду использовать термин **асинхронность**,  к этому понятию относится как конкурентность, так и параллелизм. 

Какие механизмы ассинхронности у нас есть в Ruby?
## Process

Процесс — это механизм операционной системы, который позволяет запустить несколько независимых программ.

В Ruby процессы представляют собой запуск отдельных экземпляров интерпретатора, где каждый экземпляр работает в своём изолированном адресном пространстве. Это позволяет обойти ограничение GIL (Global Interpreter Lock), характерное для MRI, и использовать все доступные ядра. 

Пример простого использования `fork`:

```ruby
pid = fork do
  puts "Это выполняется в дочернем процессе"
end

Process.wait(pid)
puts "Дочерний процесс завершён"
```

Однако, такие процессы не могут иметь общих переменных. И координировать процессы становится сложно: нужно использовать сокеты, порты, внешние ресурсы (бд, редис, очереди). 

**Преимущества**: 
- используются все ядра

**Недостатки**:
- самый ресурсоемкий вариант
- нет простого способа коммуницировать между процессами

## Thread

Потоки в Ruby позволяют выполнять несколько нитей внутри одного процесса, что особенно полезно для I/O-ориентированных задач. Нить (thread) — это единица исполнения внутри процесса операционной системы. Она позволяет выполнять несколько задач одновременно, используя ресурсы одного процесса. Хотя использование потоков позволяет добиться конкурентного выполнения, в MRI ограничение GIL (Global Interpreter Lock) не позволяет выполнять CPU-ориентированные задачи параллельно в полном объёме. Тем не менее, для задач, где программа часто ожидает внешние события, потоки становятся удобным инструментом.

Минимальный пример использования потоков:

```ruby
thread = Thread.new do
  puts "Работа потока"
  sleep 1
  puts "Поток завершён"
end

thread.join
puts "Основной поток продолжил выполнение"
```

При использовании потоков важно уделять внимание синхронизации доступа к разделяемым данным, чтобы избежать гонок и дедлоков.

**Преимущества**:
- эффективнее, чем процессы
- могут иметь общие переменные в рамках одного процесса
**Недостатки**:
- используется 1 ядро
- ограничение GIL - параллельно исполняется только 1 поток
- все же, высокое потребление ресурсов, если сравнивать с легковесными потоками (см Fiber)

## Fiber

В современных языках программирования наряду с потоками существуют встроенные легковесные примитивы для организации асинхронного кода: горутины в Go, корутины в Kotlin, файберы в Ruby.

Файберы – это легковесные примитивы для реализации кооперативной многозадачности, позволяющие явно передавать управление между различными блоками кода. Они работают в рамках одного потока, что упрощает управление состоянием, однако ответственность за передачу управления полностью ложится на программиста. Файберы отлично подходят для реализации асинхронного ввода-вывода и нелинейного исполнения кода.

Пример использования файбера:

```ruby
fiber = Fiber.new do
  puts "Начало работы файбера"
  Fiber.yield
  puts "Возобновление работы файбера"
end

fiber.resume
puts "Между резюме"
fiber.resume
```

**Преимущества:**
* простота использования
* эффективность по ресурсам

**Недостатки:**
* используется только одно ядро

### Ractor



```ruby
results = urls.map do |url|
  Ractor.new(url) do |url|
    response(url)
  end
end

puts results.map(&:take)
```



В мире параллельного программирования Ruby, где мы стремимся выжать максимум производительности из наших приложений, часто возникают вопросы: как эффективно использовать ресурсы, не прибегая к сложным и потенциально опасным механизмам, таким как потоки? И тут на сцену выходят Actors.

**Что такое Actors?**

Actors – это модель параллельного программирования, основанная на идее независимых сущностей, которые обмениваются сообщениями. Представьте себе актеров в театре: каждый из них выполняет свою роль, взаимодействует с другими актерами, но при этом не мешает друг другу. В Ruby Actors реализованы с помощью модуля `Concurrent::Actor`.

**Чем Actors отличаются от Threads?**

Традиционные потоки (Threads) в Ruby используют общую память, что приводит к проблемам с синхронизацией и гонками данных. Для решения этих проблем требуются сложные блокировки и мьютексы, что усложняет код и увеличивает вероятность ошибок. Actors же, напротив, работают с изолированной памятью. Каждый Actor имеет собственное состояние, и взаимодействие между ними происходит только через обмен сообщениями. Это исключает проблемы с общим состоянием и упрощает отладку.

**Fibers vs Actors: тонкости различий**

Fibers – это легковесные потоки исполнения, которые позволяют переключаться между разными точками выполнения в одном потоке. Они полезны для организации асинхронного кода, но не обеспечивают настоящую параллельность, так как все они выполняются в одном потоке. Actors же, благодаря своей изолированной природе, могут выполняться параллельно на нескольких ядрах процессора, обеспечивая реальный прирост производительности.

**Преимущества использования Actors:**

*   **Безопасность:** Изолированное состояние исключает проблемы с общим состоянием и гонками данных.
*   **Простота:** Код становится более читаемым и понятным благодаря отсутствию сложных блокировок.
*   **Производительность:** Реальная параллельность позволяет эффективно использовать ресурсы процессора.
*   **Масштабируемость:** Легко масштабировать приложение, добавляя новых Actors.

**Заключение**

Actors – это мощный инструмент для параллельного программирования в Ruby, который позволяет избежать многих проблем, связанных с потоками и файбэрами. Если вы стремитесь к безопасному, простому и производительному коду, стоит обратить внимание на Actors.
