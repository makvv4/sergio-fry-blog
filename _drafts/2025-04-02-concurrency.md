---
layout: post
date: 
title: Параллельность и конкурентность в Ruby
---
## Зачем вообще разработчику думать о конкурентности?

**Скорость!**

Нам нужно обработать 1000 документов? Нам нужно сделать 1000 запросов? Нам нужно выполнить 1000 фоновых задач? В современном мире, где пользователи ожидают мгновенный отклик, игнорировать возможность параллельного выполнения задач – значит, обрекать приложение на медленную и неэффективную работу. Конкурентность позволяет нам делать несколько вещей одновременно, используя ресурсы процессора максимально эффективно.

Чтобы наглядно это показать, рассмотрим пример. Допустим, нам нужно сделать 100 HTTP-запросов к внешнему API.  Если мы будем выполнять их последовательно, то общее время выполнения будет зависеть от времени выполнения *каждого* запроса, умноженного на 100.  А если мы используем конкурентность, мы можем отправлять несколько запросов одновременно, значительно сокращая общее время ожидания.

Вот пример кода на Python, демонстрирующий, как можно быстрее сделать 100 HTTP-запросов, используя `asyncio` и `aiohttp`:

```python
import asyncio
import aiohttp

async def fetch(session, url):
    async with session.get(url) as response:
        return await response.text()

async def main():
    urls = [f"https://example.com/{i}" for i in range(100)] # Замените example.com на реальный API
    async with aiohttp.ClientSession() as session:
        tasks = [fetch(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
        # Обработка результатов
        # print(results)

if __name__ == "__main__":
    asyncio.run(main())
```

**Пояснения к коду:**

*   **`asyncio`**:  Библиотека для написания асинхронного кода.
*   **`aiohttp`**:  Асинхронная HTTP-клиентская библиотека.
*   **`fetch(session, url)`**:  Асинхронная функция, выполняющая HTTP-запрос к указанному URL.
*   **`async with aiohttp.ClientSession() as session:`**:  Создает сессию для выполнения HTTP-запросов. Использование сессии позволяет повторно использовать соединения, что повышает производительность.
*   **`tasks = [fetch(session, url) for url in urls]`**:  Создает список задач, каждая из которых представляет собой асинхронный HTTP-запрос.
*   **`await asyncio.gather(*tasks)`**:  Запускает все задачи одновременно и ждет их завершения.  `asyncio.gather`  позволяет эффективно управлять параллельным выполнением задач.

Этот пример демонстрирует, как асинхронность и конкурентность могут значительно ускорить выполнение задач, особенно когда речь идет о работе с внешними ресурсами, такими как HTTP-запросы.  Понимание принципов конкурентности и умение их применять – важный навык для современного разработчика.

На самом деле, в твоем Ruby on Rails ты уже используешь конкурентность, но можешь этого знать. Например, сервер puma использует потоки и процессы для параллельной обработки запросов от пользователя. А Sidekiq обрабатывает задачи в параллели.

Сразу же всплывает нюанс: параллельность или конкурентность? Чуть позже разберемся и с этим.

Для начала нужно запомнить, что для того, чтобы одна задача/запрос/вызов не заставляла ждать другую - нужна эта самая конкурентность.

А еще у нас у каждого уже давно не сервера, а "*суперкомпьютеры*", на которых куча ядер и которые хочется тоже занять с пользой, чтобы ускорить наше приложение.




## Process

В Ruby процессы представляют собой запуск отдельных экземпляров интерпретатора, где каждый экземпляр работает в своём изолированном адресном пространстве. Это позволяет обойти ограничение GIL (Global Interpreter Lock), характерное для MRI, и использовать все доступные ядра. Такой подход особенно полезен, когда требуется полная изоляция между задачами, либо при работе с вычислительно интенсивными операциями, где обмен данными осуществляется через межпроцессное взаимодействие.

Пример простого использования fork:

```ruby
pid = fork do
  puts "Это выполняется в дочернем процессе"
end

Process.wait(pid)
puts "Дочерний процесс завершён"
```

Однако стоит учитывать, что создание процессов может быть затратным, а обмен данными между ними требует использования специальных механизмов (сокеты, очереди сообщений и т.д.).


## Thread

Потоки в Ruby позволяют выполнять несколько нитей внутри одного процесса, что особенно полезно для I/O-ориентированных задач. Хотя использование потоков позволяет добиться конкурентного выполнения, в MRI ограничение GIL не позволяет выполнять CPU-ориентированные задачи параллельно в полном объёме. Тем не менее, для задач, где программа часто ожидает внешние события, потоки становятся удобным инструментом.

Минимальный пример использования потоков:

```ruby
thread = Thread.new do
  puts "Работа потока"
  sleep 1
  puts "Поток завершён"
end

thread.join
puts "Основной поток продолжил выполнение"
```

При использовании потоков важно уделять внимание синхронизации доступа к разделяемым данным, чтобы избежать гонок и дедлоков.

## Fiber

Файберы – это лёгкие примитивы для реализации кооперативной многозадачности, позволяющие явно передавать управление между различными блоками кода. Они работают в рамках одного потока, что упрощает управление состоянием, однако ответственность за передачу управления полностью ложится на программиста. Фиберы отлично подходят для реализации асинхронного ввода-вывода и нелинейного исполнения кода.

Пример использования фибера:

```ruby
fiber = Fiber.new do
  puts "Начало работы фибера"
  Fiber.yield
  puts "Возобновление работы фибера"
end

fiber.resume
puts "Между резюме"
fiber.resume
```

Такой подход не позволит достичь истинного параллелизма для вычислительно интенсивных задач, но может существенно упростить архитектуру для асинхронных операций.

---

### Ractor

Нововведение Ruby 3 – Ractor – создано для решения проблемы GIL, предоставляя возможность настоящего параллелизма. Каждый Ractor работает в полностью изолированном окружении, что позволяет безопасно обмениваться данными между ними посредством передачи сообщений. Это делает Ractor мощным инструментом для построения масштабируемых приложений, способных эффективно использовать все ядра процессора.

Простой пример работы с Ractor:

```ruby
ractor = Ractor.new do
  "Привет из Ractor"
end

message = ractor.take
puts message
```

При работе с Ractor важно помнить, что объекты не могут быть разделены между Ractor'ами без специальной обработки, что требует иной модели обмена данными и может потребовать адаптации существующего кода.

---

### Заключение

В условиях стремительного роста вычислительных мощностей и увеличения числа ядер современных систем умение работать с параллельным и конкурентным выполнением кода становится жизненно необходимым навыком для разработчика. Знание принципов работы процессов, потоков, фиберов и Ractor позволяет выбирать оптимальное решение для каждой конкретной задачи, обеспечивая масштабируемость и эффективность программ. Современный программист должен уметь комбинировать эти инструменты в своём арсенале, чтобы создавать надёжные и производительные приложения.

---

Зачем вообще разработчику думать о конкурентности? 