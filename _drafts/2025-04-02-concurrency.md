---
layout: post
date: 
title: Параллельность и конкурентность в Ruby
---

## Зачем вообще разработчику думать о конкурентности?

**Скорость**!

Нам нужно обработать 1000 документов? Нам нужно сделать 1000 запросов? Нам нужно выполнить 1000 фоновых задач? В современном мире, где время - деньги, игнорировать конкурентность – значит упускать огромные возможности для оптимизации производительности.

Рассмотрим простой пример: если мы делаем 100 HTTP-запросов последовательно, это займет значительно больше времени, чем если мы сделаем их параллельно.

Вот пример, как можно сделать 100 HTTP-запросов параллельно с использованием библиотеки `HTTParty` в Ruby:

```ruby
require 'httparty'
require 'concurrent'

urls = (1..100).map { |i| "https://example.com/#{i}" }

fast_get = Concurrent::FastFuture.new do
  HTTParty.get(urls)
end

results = fast_get.value

puts "Получено #{results.size} результатов."
```

В этом примере `Concurrent::FastFuture` позволяет выполнять запросы параллельно, что значительно сокращает общее время выполнения.

Помните: конкурентность – это не просто "модно". Это инструмент, который позволяет создавать более быстрые и эффективные приложения.

На самом деле, в твоем Ruby on Rails ты уже используешь конкурентность, но можешь этого знать. Например, сервер puma использует потоки и процессы для параллельной обработки запросов от пользователя. А Sidekiq обрабатывает задачи в параллели.

Сразу же всплывает нюанс: параллельность или конкурентность? Чуть позже разберемся и с этим.

Для начала нужно запомнить, что для того, чтобы одна задача/запрос/вызов не заставляла ждать другую - нужна эта самая конкурентность.

А еще у нас у каждого уже давно не сервера, а "*суперкомпьютеры*", на которых куча ядер и которые хочется тоже занять с пользой, чтобы ускорить наше приложение.




## Process

В Ruby процессы представляют собой запуск отдельных экземпляров интерпретатора, где каждый экземпляр работает в своём изолированном адресном пространстве. Это позволяет обойти ограничение GIL (Global Interpreter Lock), характерное для MRI, и использовать все доступные ядра. Такой подход особенно полезен, когда требуется полная изоляция между задачами, либо при работе с вычислительно интенсивными операциями, где обмен данными осуществляется через межпроцессное взаимодействие.

Пример простого использования fork:

```ruby
pid = fork do
  puts "Это выполняется в дочернем процессе"
end

Process.wait(pid)
puts "Дочерний процесс завершён"
```

Однако стоит учитывать, что создание процессов может быть затратным, а обмен данными между ними требует использования специальных механизмов (сокеты, очереди сообщений и т.д.).


## Thread

Потоки в Ruby позволяют выполнять несколько нитей внутри одного процесса, что особенно полезно для I/O-ориентированных задач. Хотя использование потоков позволяет добиться конкурентного выполнения, в MRI ограничение GIL не позволяет выполнять CPU-ориентированные задачи параллельно в полном объёме. Тем не менее, для задач, где программа часто ожидает внешние события, потоки становятся удобным инструментом.

Минимальный пример использования потоков:

```ruby
thread = Thread.new do
  puts "Работа потока"
  sleep 1
  puts "Поток завершён"
end

thread.join
puts "Основной поток продолжил выполнение"
```

При использовании потоков важно уделять внимание синхронизации доступа к разделяемым данным, чтобы избежать гонок и дедлоков.

## Fiber

Файберы – это лёгкие примитивы для реализации кооперативной многозадачности, позволяющие явно передавать управление между различными блоками кода. Они работают в рамках одного потока, что упрощает управление состоянием, однако ответственность за передачу управления полностью ложится на программиста. Фиберы отлично подходят для реализации асинхронного ввода-вывода и нелинейного исполнения кода.

Пример использования фибера:

```ruby
fiber = Fiber.new do
  puts "Начало работы фибера"
  Fiber.yield
  puts "Возобновление работы фибера"
end

fiber.resume
puts "Между резюме"
fiber.resume
```

Такой подход не позволит достичь истинного параллелизма для вычислительно интенсивных задач, но может существенно упростить архитектуру для асинхронных операций.

---

### Ractor

Нововведение Ruby 3 – Ractor – создано для решения проблемы GIL, предоставляя возможность настоящего параллелизма. Каждый Ractor работает в полностью изолированном окружении, что позволяет безопасно обмениваться данными между ними посредством передачи сообщений. Это делает Ractor мощным инструментом для построения масштабируемых приложений, способных эффективно использовать все ядра процессора.

Простой пример работы с Ractor:

```ruby
ractor = Ractor.new do
  "Привет из Ractor"
end

message = ractor.take
puts message
```

При работе с Ractor важно помнить, что объекты не могут быть разделены между Ractor'ами без специальной обработки, что требует иной модели обмена данными и может потребовать адаптации существующего кода.

---

### Заключение

В условиях стремительного роста вычислительных мощностей и увеличения числа ядер современных систем умение работать с параллельным и конкурентным выполнением кода становится жизненно необходимым навыком для разработчика. Знание принципов работы процессов, потоков, фиберов и Ractor позволяет выбирать оптимальное решение для каждой конкретной задачи, обеспечивая масштабируемость и эффективность программ. Современный программист должен уметь комбинировать эти инструменты в своём арсенале, чтобы создавать надёжные и производительные приложения.

---

Зачем вообще разработчику думать о конкурентности? 