---
layout: post
date: 
title: Параллельность и конкурентность в Ruby
---

Зачем вообще разработчику думать о конкурентности?

**Скорость**!

Нам нужно обработать 1000 документов? Нам нужно сделать 1000 запросов? Нам нужно выполнить 1000 фоновых задач? В современном мире, где время - деньги, игнорировать конкурентность – значит упускать огромные возможности для оптимизации производительности.

Рассмотрим простой пример: если мы делаем 100 HTTP-запросов последовательно, это займет значительно больше времени, чем если мы сделаем их параллельно.

```ruby
require 'net/http'
require 'uri'

def response(url) = Net::HTTP.get_response(URI.parse(url))

urls = (1..100).map { |i| "https://example.com/#{i}" }
results = []

urls.each { |url| results << response(url) } # 100 sec

urls.each { |url| Thread.new { results << response(url) } } # 1 sec
```

Почему это возможно? Дело в том, что в реальных задачах процессор почти все время простаивает, потому что мы ждем ответа от устройств ввода/вывода, таких как сеть, диск, база данных (тоже сеть). А еще у нас у каждого уже давно не сервера, а "*суперкомпьютеры*", на которых куча ядер. Так что тут есть большой простор для ускорения наших приложений.

А пока процессор простаивает, почему бы его не занять чем-то полезным, например, обработкой следующей задачи. А как придет ответ от сети, можно переключиться обратно.
В Ruby on Rails конкурентность уже присутствует: Puma использует потоки и процессы для параллельной обработки запросов, а Sidekiq выполняет задачи параллельно.

Для эффективной работы необходимо, чтобы одна задача не блокировала другие, и для этого нужна конкурентность.

Часто возникают вопросы о параллельности и конкурентности. В чем же разница?

**Параллельность** подразумевает одновременное выполнение нескольких задач на разных ядрах процессора. Это "реальное" выполнение одновременно.

**Конкурентность** же – это способность системы обрабатывать несколько задач, создавая иллюзию одновременного выполнения. Это может достигаться путем быстрого переключения между задачами на одном ядре.

Ключевое отличие: параллельность требует нескольких ядер, а конкурентность – нет. Конкурентность позволяет добиться прогресса, даже если у вас только одно ядро.

Тут можно вспомнить про GIL, который ограничивает параллельное выполнение в MRI. Из-за этого механизма программа на ruby не может задействовать больше 1 ядра CPU. Это серьезное ограничение, но его можно преодолеть. Увидим чуть позже.

Какие механизмы у нас есть в Ruby?

## Process

В Ruby процессы представляют собой запуск отдельных экземпляров интерпретатора, где каждый экземпляр работает в своём изолированном адресном пространстве. Это позволяет обойти ограничение GIL (Global Interpreter Lock), характерное для MRI, и использовать все доступные ядра. Такой подход особенно полезен, когда требуется полная изоляция между задачами, либо при работе с вычислительно интенсивными операциями, где обмен данными осуществляется через межпроцессное взаимодействие.

Пример простого использования fork:

```ruby
pid = fork do
  puts "Это выполняется в дочернем процессе"
end

Process.wait(pid)
puts "Дочерний процесс завершён"
```

Однако стоит учитывать, что создание процессов может быть затратным, а обмен данными между ними требует использования специальных механизмов (сокеты, очереди сообщений и т.д.).


## Thread

Потоки в Ruby позволяют выполнять несколько нитей внутри одного процесса, что особенно полезно для I/O-ориентированных задач. Хотя использование потоков позволяет добиться конкурентного выполнения, в MRI ограничение GIL не позволяет выполнять CPU-ориентированные задачи параллельно в полном объёме. Тем не менее, для задач, где программа часто ожидает внешние события, потоки становятся удобным инструментом.

Минимальный пример использования потоков:

```ruby
thread = Thread.new do
  puts "Работа потока"
  sleep 1
  puts "Поток завершён"
end

thread.join
puts "Основной поток продолжил выполнение"
```

При использовании потоков важно уделять внимание синхронизации доступа к разделяемым данным, чтобы избежать гонок и дедлоков.

## Fiber

Файберы – это лёгкие примитивы для реализации кооперативной многозадачности, позволяющие явно передавать управление между различными блоками кода. Они работают в рамках одного потока, что упрощает управление состоянием, однако ответственность за передачу управления полностью ложится на программиста. Фиберы отлично подходят для реализации асинхронного ввода-вывода и нелинейного исполнения кода.

Пример использования фибера:

```ruby
fiber = Fiber.new do
  puts "Начало работы фибера"
  Fiber.yield
  puts "Возобновление работы фибера"
end

fiber.resume
puts "Между резюме"
fiber.resume
```

Такой подход не позволит достичь истинного параллелизма для вычислительно интенсивных задач, но может существенно упростить архитектуру для асинхронных операций.

---

### Ractor

Нововведение Ruby 3 – Ractor – создано для решения проблемы GIL, предоставляя возможность настоящего параллелизма. Каждый Ractor работает в полностью изолированном окружении, что позволяет безопасно обмениваться данными между ними посредством передачи сообщений. Это делает Ractor мощным инструментом для построения масштабируемых приложений, способных эффективно использовать все ядра процессора.

Простой пример работы с Ractor:

```ruby
ractor = Ractor.new do
  "Привет из Ractor"
end

message = ractor.take
puts message
```

При работе с Ractor важно помнить, что объекты не могут быть разделены между Ractor'ами без специальной обработки, что требует иной модели обмена данными и может потребовать адаптации существующего кода.

---

### Заключение

В условиях стремительного роста вычислительных мощностей и увеличения числа ядер современных систем умение работать с параллельным и конкурентным выполнением кода становится жизненно необходимым навыком для разработчика. Знание принципов работы процессов, потоков, фиберов и Ractor позволяет выбирать оптимальное решение для каждой конкретной задачи, обеспечивая масштабируемость и эффективность программ. Современный программист должен уметь комбинировать эти инструменты в своём арсенале, чтобы создавать надёжные и производительные приложения.

---

Зачем вообще разработчику думать о конкурентности? 